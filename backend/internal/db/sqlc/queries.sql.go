// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
)

const companyExists = `-- name: CompanyExists :one
SELECT EXISTS(SELECT 1 FROM companies WHERE id = $1)
`

func (q *Queries) CompanyExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, companyExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countComments = `-- name: CountComments :one
SELECT COUNT(*) FROM company_comments
`

func (q *Queries) CountComments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countComments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCompanies = `-- name: CountCompanies :one
SELECT COUNT(*) FROM companies
`

func (q *Queries) CountCompanies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCompanies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCompaniesByCategory = `-- name: CountCompaniesByCategory :one
SELECT COUNT(*) FROM companies WHERE category = $1
`

func (q *Queries) CountCompaniesByCategory(ctx context.Context, category string) (int64, error) {
	row := q.db.QueryRow(ctx, countCompaniesByCategory, category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRatings = `-- name: CountRatings :one
SELECT COUNT(*) FROM company_ratings
`

func (q *Queries) CountRatings(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRatings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotes = `-- name: CountVotes :one
SELECT COUNT(*) FROM votes
`

func (q *Queries) CountVotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO company_comments (company_id, content, is_current_employee, session_id)
VALUES ($1, $2, $3, $4)
RETURNING id, company_id, content, is_current_employee, session_id, upvotes, created_at
`

type CreateCommentParams struct {
	CompanyID         int32   `json:"company_id"`
	Content           string  `json:"content"`
	IsCurrentEmployee *bool   `json:"is_current_employee"`
	SessionID         *string `json:"session_id"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (CompanyComment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.CompanyID,
		arg.Content,
		arg.IsCurrentEmployee,
		arg.SessionID,
	)
	var i CompanyComment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Content,
		&i.IsCurrentEmployee,
		&i.SessionID,
		&i.Upvotes,
		&i.CreatedAt,
	)
	return i, err
}

const createRating = `-- name: CreateRating :one
INSERT INTO company_ratings (company_id, criterion, score, session_id)
VALUES ($1, $2, $3, $4)
RETURNING id, company_id, criterion, score, session_id, created_at
`

type CreateRatingParams struct {
	CompanyID int32   `json:"company_id"`
	Criterion string  `json:"criterion"`
	Score     int32   `json:"score"`
	SessionID *string `json:"session_id"`
}

func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (CompanyRating, error) {
	row := q.db.QueryRow(ctx, createRating,
		arg.CompanyID,
		arg.Criterion,
		arg.Score,
		arg.SessionID,
	)
	var i CompanyRating
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Criterion,
		&i.Score,
		&i.SessionID,
		&i.CreatedAt,
	)
	return i, err
}

const createVote = `-- name: CreateVote :one
INSERT INTO votes (winner_id, loser_id, session_id)
VALUES ($1, $2, $3)
RETURNING id, winner_id, loser_id, session_id, created_at
`

type CreateVoteParams struct {
	WinnerID  int32   `json:"winner_id"`
	LoserID   int32   `json:"loser_id"`
	SessionID *string `json:"session_id"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, createVote, arg.WinnerID, arg.LoserID, arg.SessionID)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.WinnerID,
		&i.LoserID,
		&i.SessionID,
		&i.CreatedAt,
	)
	return i, err
}

const getAggregatedRatings = `-- name: GetAggregatedRatings :many
SELECT criterion, AVG(score)::float as average_score, COUNT(*) as total_ratings
FROM company_ratings
WHERE company_id = $1
GROUP BY criterion
`

type GetAggregatedRatingsRow struct {
	Criterion    string  `json:"criterion"`
	AverageScore float64 `json:"average_score"`
	TotalRatings int64   `json:"total_ratings"`
}

func (q *Queries) GetAggregatedRatings(ctx context.Context, companyID int32) ([]GetAggregatedRatingsRow, error) {
	rows, err := q.db.Query(ctx, getAggregatedRatings, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAggregatedRatingsRow{}
	for rows.Next() {
		var i GetAggregatedRatingsRow
		if err := rows.Scan(&i.Criterion, &i.AverageScore, &i.TotalRatings); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT category, COUNT(*) as count
FROM companies
GROUP BY category
ORDER BY count DESC
`

type GetCategoriesRow struct {
	Category string `json:"category"`
	Count    int64  `json:"count"`
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriesRow{}
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE id = $1
`

func (q *Queries) GetCompanyByID(ctx context.Context, id int32) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.Description,
		&i.Website,
		&i.Category,
		&i.Tags,
		&i.FoundedYear,
		&i.HqLocation,
		&i.EmployeeRange,
		&i.FundingStage,
		&i.EloRating,
		&i.TotalVotes,
		&i.Wins,
		&i.Losses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyBySlug = `-- name: GetCompanyBySlug :one
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE slug = $1
`

func (q *Queries) GetCompanyBySlug(ctx context.Context, slug string) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyBySlug, slug)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.Description,
		&i.Website,
		&i.Category,
		&i.Tags,
		&i.FoundedYear,
		&i.HqLocation,
		&i.EmployeeRange,
		&i.FundingStage,
		&i.EloRating,
		&i.TotalVotes,
		&i.Wins,
		&i.Losses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyComments = `-- name: GetCompanyComments :many
SELECT id, company_id, content, is_current_employee, session_id, upvotes, created_at
FROM company_comments
WHERE company_id = $1
ORDER BY upvotes DESC, created_at DESC
LIMIT 100
`

func (q *Queries) GetCompanyComments(ctx context.Context, companyID int32) ([]CompanyComment, error) {
	rows, err := q.db.Query(ctx, getCompanyComments, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CompanyComment{}
	for rows.Next() {
		var i CompanyComment
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Content,
			&i.IsCurrentEmployee,
			&i.SessionID,
			&i.Upvotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyEloRating = `-- name: GetCompanyEloRating :one
SELECT elo_rating FROM companies WHERE id = $1
`

func (q *Queries) GetCompanyEloRating(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, getCompanyEloRating, id)
	var elo_rating int32
	err := row.Scan(&elo_rating)
	return elo_rating, err
}

const getCompanyIDBySlug = `-- name: GetCompanyIDBySlug :one
SELECT id FROM companies WHERE slug = $1
`

func (q *Queries) GetCompanyIDBySlug(ctx context.Context, slug string) (int32, error) {
	row := q.db.QueryRow(ctx, getCompanyIDBySlug, slug)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getCompanyRank = `-- name: GetCompanyRank :one
SELECT COUNT(*) + 1 FROM companies WHERE elo_rating > $1
`

func (q *Queries) GetCompanyRank(ctx context.Context, eloRating int32) (int32, error) {
	row := q.db.QueryRow(ctx, getCompanyRank, eloRating)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getDistinctCategories = `-- name: GetDistinctCategories :many
SELECT DISTINCT category FROM companies ORDER BY category
`

func (q *Queries) GetDistinctCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
ORDER BY elo_rating DESC, total_votes DESC
LIMIT $1 OFFSET $2
`

type GetLeaderboardParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetLeaderboard(ctx context.Context, arg GetLeaderboardParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, getLeaderboard, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardByCategory = `-- name: GetLeaderboardByCategory :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE category = $1
ORDER BY elo_rating DESC, total_votes DESC
LIMIT $2 OFFSET $3
`

type GetLeaderboardByCategoryParams struct {
	Category string `json:"category"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetLeaderboardByCategory(ctx context.Context, arg GetLeaderboardByCategoryParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, getLeaderboardByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMatchup = `-- name: GetRandomMatchup :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
ORDER BY RANDOM()
LIMIT 2
`

func (q *Queries) GetRandomMatchup(ctx context.Context) ([]Company, error) {
	rows, err := q.db.Query(ctx, getRandomMatchup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMatchupByCategory = `-- name: GetRandomMatchupByCategory :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE category = $1
ORDER BY RANDOM()
LIMIT 2
`

func (q *Queries) GetRandomMatchupByCategory(ctx context.Context, category string) ([]Company, error) {
	rows, err := q.db.Query(ctx, getRandomMatchupByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompanies = `-- name: ListCompanies :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
ORDER BY elo_rating DESC, total_votes DESC
`

func (q *Queries) ListCompanies(ctx context.Context) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompaniesByCategory = `-- name: ListCompaniesByCategory :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE category = $1
ORDER BY elo_rating DESC, total_votes DESC
`

func (q *Queries) ListCompaniesByCategory(ctx context.Context, category string) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompaniesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompanies = `-- name: SearchCompanies :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE LOWER(name) LIKE $1 OR LOWER(description) LIKE $1
ORDER BY elo_rating DESC, total_votes DESC
`

func (q *Queries) SearchCompanies(ctx context.Context, name string) ([]Company, error) {
	rows, err := q.db.Query(ctx, searchCompanies, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompaniesByCategory = `-- name: SearchCompaniesByCategory :many
SELECT id, name, slug, logo_url, description, website, category, tags,
       founded_year, hq_location, employee_range, funding_stage,
       elo_rating, total_votes, wins, losses, created_at, updated_at
FROM companies
WHERE category = $1 AND (LOWER(name) LIKE $2 OR LOWER(description) LIKE $2)
ORDER BY elo_rating DESC, total_votes DESC
`

type SearchCompaniesByCategoryParams struct {
	Category string `json:"category"`
	Name     string `json:"name"`
}

func (q *Queries) SearchCompaniesByCategory(ctx context.Context, arg SearchCompaniesByCategoryParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, searchCompaniesByCategory, arg.Category, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.Description,
			&i.Website,
			&i.Category,
			&i.Tags,
			&i.FoundedYear,
			&i.HqLocation,
			&i.EmployeeRange,
			&i.FundingStage,
			&i.EloRating,
			&i.TotalVotes,
			&i.Wins,
			&i.Losses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompanyAfterLoss = `-- name: UpdateCompanyAfterLoss :exec
UPDATE companies 
SET elo_rating = $2, total_votes = total_votes + 1, losses = losses + 1, updated_at = NOW()
WHERE id = $1
`

type UpdateCompanyAfterLossParams struct {
	ID        int32 `json:"id"`
	EloRating int32 `json:"elo_rating"`
}

func (q *Queries) UpdateCompanyAfterLoss(ctx context.Context, arg UpdateCompanyAfterLossParams) error {
	_, err := q.db.Exec(ctx, updateCompanyAfterLoss, arg.ID, arg.EloRating)
	return err
}

const updateCompanyAfterWin = `-- name: UpdateCompanyAfterWin :exec
UPDATE companies 
SET elo_rating = $2, total_votes = total_votes + 1, wins = wins + 1, updated_at = NOW()
WHERE id = $1
`

type UpdateCompanyAfterWinParams struct {
	ID        int32 `json:"id"`
	EloRating int32 `json:"elo_rating"`
}

func (q *Queries) UpdateCompanyAfterWin(ctx context.Context, arg UpdateCompanyAfterWinParams) error {
	_, err := q.db.Exec(ctx, updateCompanyAfterWin, arg.ID, arg.EloRating)
	return err
}

const upvoteComment = `-- name: UpvoteComment :one
UPDATE company_comments
SET upvotes = upvotes + 1
WHERE id = $1
RETURNING id, company_id, content, is_current_employee, session_id, upvotes, created_at
`

func (q *Queries) UpvoteComment(ctx context.Context, id int32) (CompanyComment, error) {
	row := q.db.QueryRow(ctx, upvoteComment, id)
	var i CompanyComment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Content,
		&i.IsCurrentEmployee,
		&i.SessionID,
		&i.Upvotes,
		&i.CreatedAt,
	)
	return i, err
}
