// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.21.12
// source: api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";
import { Int32Value, StringValue } from "./google/protobuf/wrappers";

export const protobufPackage = "api";

/** Company represents an AI company */
export interface Company {
  id: number;
  name: string;
  slug: string;
  logoUrl: string | undefined;
  description: string | undefined;
  website: string | undefined;
  category: string;
  tags: string[];
  foundedYear: number | undefined;
  hqLocation: string | undefined;
  employeeRange: string | undefined;
  fundingStage: string | undefined;
  eloRating: number;
  totalVotes: number;
  wins: number;
  losses: number;
  rank: number;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

/** CompanyList is a list of companies */
export interface CompanyList {
  companies: Company[];
}

/** Vote represents a head-to-head vote */
export interface Vote {
  id: number;
  winnerId: number;
  loserId: number;
  sessionId: string | undefined;
  createdAt: Date | undefined;
}

/** VoteRequest represents a voting request */
export interface VoteRequest {
  winnerId: number;
  loserId: number;
  sessionId: string;
}

/** VoteResponse represents the voting response with updated ELOs */
export interface VoteResponse {
  winner: Company | undefined;
  loser: Company | undefined;
  winnerEloDiff: number;
  loserEloDiff: number;
}

/** MatchupPair represents two companies for voting */
export interface MatchupPair {
  company1: Company | undefined;
  company2: Company | undefined;
}

/** CompanyRating represents a rating for a specific criterion */
export interface CompanyRating {
  id: number;
  companyId: number;
  criterion: string;
  score: number;
  sessionId: string | undefined;
  createdAt: Date | undefined;
}

/** RatingRequest represents a rating submission */
export interface RatingRequest {
  companyId: number;
  criterion: string;
  score: number;
  sessionId: string;
}

/** AggregatedRating represents aggregated ratings for a criterion */
export interface AggregatedRating {
  criterion: string;
  averageScore: number;
  totalRatings: number;
}

/** AggregatedRatingList is a list of aggregated ratings */
export interface AggregatedRatingList {
  ratings: AggregatedRating[];
}

/** CompanyComment represents a comment/review */
export interface CompanyComment {
  id: number;
  companyId: number;
  content: string;
  isCurrentEmployee: boolean;
  sessionId: string | undefined;
  upvotes: number;
  createdAt: Date | undefined;
}

/** CommentRequest represents a comment submission */
export interface CommentRequest {
  companyId: number;
  content: string;
  isCurrentEmployee: boolean;
  sessionId: string;
}

/** CommentList is a list of comments */
export interface CommentList {
  comments: CompanyComment[];
}

/** LeaderboardRequest represents a leaderboard query */
export interface LeaderboardRequest {
  category: string;
  page: number;
  pageSize: number;
}

/** LeaderboardResponse represents the leaderboard data */
export interface LeaderboardResponse {
  companies: Company[];
  totalCount: number;
  page: number;
  pageSize: number;
}

/** StatsResponse represents overall platform stats */
export interface StatsResponse {
  totalCompanies: number;
  totalVotes: number;
  totalRatings: number;
  totalComments: number;
  categories: string[];
}

/** CategoryCount represents a category with its count */
export interface CategoryCount {
  category: string;
  count: number;
}

/** CategoryCountList is a list of category counts */
export interface CategoryCountList {
  categories: CategoryCount[];
}

/** HealthResponse represents health check response */
export interface HealthResponse {
  status: string;
  database: string;
}

/** ErrorResponse represents an error response */
export interface ErrorResponse {
  error: string;
}

/** GetCompaniesRequest represents a request to get companies */
export interface GetCompaniesRequest {
  category: string;
  search: string;
}

/** GetCompanyRequest represents a request to get a single company */
export interface GetCompanyRequest {
  slug: string;
}

/** GetMatchupRequest represents a request to get a matchup */
export interface GetMatchupRequest {
  category: string;
}

/** UpvoteCommentRequest represents a request to upvote a comment */
export interface UpvoteCommentRequest {
  commentId: number;
}

/** Empty message for requests/responses with no body */
export interface Empty {
}

function createBaseCompany(): Company {
  return {
    id: 0,
    name: "",
    slug: "",
    logoUrl: undefined,
    description: undefined,
    website: undefined,
    category: "",
    tags: [],
    foundedYear: undefined,
    hqLocation: undefined,
    employeeRange: undefined,
    fundingStage: undefined,
    eloRating: 0,
    totalVotes: 0,
    wins: 0,
    losses: 0,
    rank: 0,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const Company: MessageFns<Company> = {
  encode(message: Company, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.logoUrl !== undefined) {
      StringValue.encode({ value: message.logoUrl! }, writer.uint32(34).fork()).join();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(42).fork()).join();
    }
    if (message.website !== undefined) {
      StringValue.encode({ value: message.website! }, writer.uint32(50).fork()).join();
    }
    if (message.category !== "") {
      writer.uint32(58).string(message.category);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.foundedYear !== undefined) {
      Int32Value.encode({ value: message.foundedYear! }, writer.uint32(74).fork()).join();
    }
    if (message.hqLocation !== undefined) {
      StringValue.encode({ value: message.hqLocation! }, writer.uint32(82).fork()).join();
    }
    if (message.employeeRange !== undefined) {
      StringValue.encode({ value: message.employeeRange! }, writer.uint32(90).fork()).join();
    }
    if (message.fundingStage !== undefined) {
      StringValue.encode({ value: message.fundingStage! }, writer.uint32(98).fork()).join();
    }
    if (message.eloRating !== 0) {
      writer.uint32(104).int32(message.eloRating);
    }
    if (message.totalVotes !== 0) {
      writer.uint32(112).int32(message.totalVotes);
    }
    if (message.wins !== 0) {
      writer.uint32(120).int32(message.wins);
    }
    if (message.losses !== 0) {
      writer.uint32(128).int32(message.losses);
    }
    if (message.rank !== 0) {
      writer.uint32(136).int32(message.rank);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(146).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Company {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompany();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logoUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.website = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.foundedYear = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hqLocation = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.employeeRange = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.fundingStage = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.eloRating = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.totalVotes = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.wins = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.losses = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.rank = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Company {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      logoUrl: isSet(object.logoUrl) ? String(object.logoUrl) : undefined,
      description: isSet(object.description) ? String(object.description) : undefined,
      website: isSet(object.website) ? String(object.website) : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      foundedYear: isSet(object.foundedYear) ? Number(object.foundedYear) : undefined,
      hqLocation: isSet(object.hqLocation) ? String(object.hqLocation) : undefined,
      employeeRange: isSet(object.employeeRange) ? String(object.employeeRange) : undefined,
      fundingStage: isSet(object.fundingStage) ? String(object.fundingStage) : undefined,
      eloRating: isSet(object.eloRating) ? globalThis.Number(object.eloRating) : 0,
      totalVotes: isSet(object.totalVotes) ? globalThis.Number(object.totalVotes) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Company): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.logoUrl !== undefined) {
      obj.logoUrl = message.logoUrl;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.foundedYear !== undefined) {
      obj.foundedYear = message.foundedYear;
    }
    if (message.hqLocation !== undefined) {
      obj.hqLocation = message.hqLocation;
    }
    if (message.employeeRange !== undefined) {
      obj.employeeRange = message.employeeRange;
    }
    if (message.fundingStage !== undefined) {
      obj.fundingStage = message.fundingStage;
    }
    if (message.eloRating !== 0) {
      obj.eloRating = Math.round(message.eloRating);
    }
    if (message.totalVotes !== 0) {
      obj.totalVotes = Math.round(message.totalVotes);
    }
    if (message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Company>, I>>(base?: I): Company {
    return Company.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Company>, I>>(object: I): Company {
    const message = createBaseCompany();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.logoUrl = object.logoUrl ?? undefined;
    message.description = object.description ?? undefined;
    message.website = object.website ?? undefined;
    message.category = object.category ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.foundedYear = object.foundedYear ?? undefined;
    message.hqLocation = object.hqLocation ?? undefined;
    message.employeeRange = object.employeeRange ?? undefined;
    message.fundingStage = object.fundingStage ?? undefined;
    message.eloRating = object.eloRating ?? 0;
    message.totalVotes = object.totalVotes ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.rank = object.rank ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseCompanyList(): CompanyList {
  return { companies: [] };
}

export const CompanyList: MessageFns<CompanyList> = {
  encode(message: CompanyList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companies) {
      Company.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companies.push(Company.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyList {
    return {
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => Company.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompanyList): unknown {
    const obj: any = {};
    if (message.companies?.length) {
      obj.companies = message.companies.map((e) => Company.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompanyList>, I>>(base?: I): CompanyList {
    return CompanyList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompanyList>, I>>(object: I): CompanyList {
    const message = createBaseCompanyList();
    message.companies = object.companies?.map((e) => Company.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVote(): Vote {
  return { id: 0, winnerId: 0, loserId: 0, sessionId: undefined, createdAt: undefined };
}

export const Vote: MessageFns<Vote> = {
  encode(message: Vote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.winnerId !== 0) {
      writer.uint32(16).int32(message.winnerId);
    }
    if (message.loserId !== 0) {
      writer.uint32(24).int32(message.loserId);
    }
    if (message.sessionId !== undefined) {
      StringValue.encode({ value: message.sessionId! }, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.winnerId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.loserId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vote {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      winnerId: isSet(object.winnerId) ? globalThis.Number(object.winnerId) : 0,
      loserId: isSet(object.loserId) ? globalThis.Number(object.loserId) : 0,
      sessionId: isSet(object.sessionId) ? String(object.sessionId) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: Vote): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.winnerId !== 0) {
      obj.winnerId = Math.round(message.winnerId);
    }
    if (message.loserId !== 0) {
      obj.loserId = Math.round(message.loserId);
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vote>, I>>(base?: I): Vote {
    return Vote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {
    const message = createBaseVote();
    message.id = object.id ?? 0;
    message.winnerId = object.winnerId ?? 0;
    message.loserId = object.loserId ?? 0;
    message.sessionId = object.sessionId ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseVoteRequest(): VoteRequest {
  return { winnerId: 0, loserId: 0, sessionId: "" };
}

export const VoteRequest: MessageFns<VoteRequest> = {
  encode(message: VoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.winnerId !== 0) {
      writer.uint32(8).int32(message.winnerId);
    }
    if (message.loserId !== 0) {
      writer.uint32(16).int32(message.loserId);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.winnerId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.loserId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteRequest {
    return {
      winnerId: isSet(object.winnerId) ? globalThis.Number(object.winnerId) : 0,
      loserId: isSet(object.loserId) ? globalThis.Number(object.loserId) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: VoteRequest): unknown {
    const obj: any = {};
    if (message.winnerId !== 0) {
      obj.winnerId = Math.round(message.winnerId);
    }
    if (message.loserId !== 0) {
      obj.loserId = Math.round(message.loserId);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteRequest>, I>>(base?: I): VoteRequest {
    return VoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteRequest>, I>>(object: I): VoteRequest {
    const message = createBaseVoteRequest();
    message.winnerId = object.winnerId ?? 0;
    message.loserId = object.loserId ?? 0;
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseVoteResponse(): VoteResponse {
  return { winner: undefined, loser: undefined, winnerEloDiff: 0, loserEloDiff: 0 };
}

export const VoteResponse: MessageFns<VoteResponse> = {
  encode(message: VoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.winner !== undefined) {
      Company.encode(message.winner, writer.uint32(10).fork()).join();
    }
    if (message.loser !== undefined) {
      Company.encode(message.loser, writer.uint32(18).fork()).join();
    }
    if (message.winnerEloDiff !== 0) {
      writer.uint32(24).int32(message.winnerEloDiff);
    }
    if (message.loserEloDiff !== 0) {
      writer.uint32(32).int32(message.loserEloDiff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.winner = Company.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.loser = Company.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.winnerEloDiff = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.loserEloDiff = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteResponse {
    return {
      winner: isSet(object.winner) ? Company.fromJSON(object.winner) : undefined,
      loser: isSet(object.loser) ? Company.fromJSON(object.loser) : undefined,
      winnerEloDiff: isSet(object.winnerEloDiff) ? globalThis.Number(object.winnerEloDiff) : 0,
      loserEloDiff: isSet(object.loserEloDiff) ? globalThis.Number(object.loserEloDiff) : 0,
    };
  },

  toJSON(message: VoteResponse): unknown {
    const obj: any = {};
    if (message.winner !== undefined) {
      obj.winner = Company.toJSON(message.winner);
    }
    if (message.loser !== undefined) {
      obj.loser = Company.toJSON(message.loser);
    }
    if (message.winnerEloDiff !== 0) {
      obj.winnerEloDiff = Math.round(message.winnerEloDiff);
    }
    if (message.loserEloDiff !== 0) {
      obj.loserEloDiff = Math.round(message.loserEloDiff);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteResponse>, I>>(base?: I): VoteResponse {
    return VoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteResponse>, I>>(object: I): VoteResponse {
    const message = createBaseVoteResponse();
    message.winner = (object.winner !== undefined && object.winner !== null)
      ? Company.fromPartial(object.winner)
      : undefined;
    message.loser = (object.loser !== undefined && object.loser !== null)
      ? Company.fromPartial(object.loser)
      : undefined;
    message.winnerEloDiff = object.winnerEloDiff ?? 0;
    message.loserEloDiff = object.loserEloDiff ?? 0;
    return message;
  },
};

function createBaseMatchupPair(): MatchupPair {
  return { company1: undefined, company2: undefined };
}

export const MatchupPair: MessageFns<MatchupPair> = {
  encode(message: MatchupPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.company1 !== undefined) {
      Company.encode(message.company1, writer.uint32(10).fork()).join();
    }
    if (message.company2 !== undefined) {
      Company.encode(message.company2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchupPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchupPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.company1 = Company.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.company2 = Company.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchupPair {
    return {
      company1: isSet(object.company1) ? Company.fromJSON(object.company1) : undefined,
      company2: isSet(object.company2) ? Company.fromJSON(object.company2) : undefined,
    };
  },

  toJSON(message: MatchupPair): unknown {
    const obj: any = {};
    if (message.company1 !== undefined) {
      obj.company1 = Company.toJSON(message.company1);
    }
    if (message.company2 !== undefined) {
      obj.company2 = Company.toJSON(message.company2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchupPair>, I>>(base?: I): MatchupPair {
    return MatchupPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchupPair>, I>>(object: I): MatchupPair {
    const message = createBaseMatchupPair();
    message.company1 = (object.company1 !== undefined && object.company1 !== null)
      ? Company.fromPartial(object.company1)
      : undefined;
    message.company2 = (object.company2 !== undefined && object.company2 !== null)
      ? Company.fromPartial(object.company2)
      : undefined;
    return message;
  },
};

function createBaseCompanyRating(): CompanyRating {
  return { id: 0, companyId: 0, criterion: "", score: 0, sessionId: undefined, createdAt: undefined };
}

export const CompanyRating: MessageFns<CompanyRating> = {
  encode(message: CompanyRating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.companyId !== 0) {
      writer.uint32(16).int32(message.companyId);
    }
    if (message.criterion !== "") {
      writer.uint32(26).string(message.criterion);
    }
    if (message.score !== 0) {
      writer.uint32(32).int32(message.score);
    }
    if (message.sessionId !== undefined) {
      StringValue.encode({ value: message.sessionId! }, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyRating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.companyId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.criterion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sessionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyRating {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      companyId: isSet(object.companyId) ? globalThis.Number(object.companyId) : 0,
      criterion: isSet(object.criterion) ? globalThis.String(object.criterion) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      sessionId: isSet(object.sessionId) ? String(object.sessionId) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: CompanyRating): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.companyId !== 0) {
      obj.companyId = Math.round(message.companyId);
    }
    if (message.criterion !== "") {
      obj.criterion = message.criterion;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompanyRating>, I>>(base?: I): CompanyRating {
    return CompanyRating.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompanyRating>, I>>(object: I): CompanyRating {
    const message = createBaseCompanyRating();
    message.id = object.id ?? 0;
    message.companyId = object.companyId ?? 0;
    message.criterion = object.criterion ?? "";
    message.score = object.score ?? 0;
    message.sessionId = object.sessionId ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseRatingRequest(): RatingRequest {
  return { companyId: 0, criterion: "", score: 0, sessionId: "" };
}

export const RatingRequest: MessageFns<RatingRequest> = {
  encode(message: RatingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.companyId !== 0) {
      writer.uint32(8).int32(message.companyId);
    }
    if (message.criterion !== "") {
      writer.uint32(18).string(message.criterion);
    }
    if (message.score !== 0) {
      writer.uint32(24).int32(message.score);
    }
    if (message.sessionId !== "") {
      writer.uint32(34).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RatingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRatingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.companyId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.criterion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RatingRequest {
    return {
      companyId: isSet(object.companyId) ? globalThis.Number(object.companyId) : 0,
      criterion: isSet(object.criterion) ? globalThis.String(object.criterion) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: RatingRequest): unknown {
    const obj: any = {};
    if (message.companyId !== 0) {
      obj.companyId = Math.round(message.companyId);
    }
    if (message.criterion !== "") {
      obj.criterion = message.criterion;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RatingRequest>, I>>(base?: I): RatingRequest {
    return RatingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RatingRequest>, I>>(object: I): RatingRequest {
    const message = createBaseRatingRequest();
    message.companyId = object.companyId ?? 0;
    message.criterion = object.criterion ?? "";
    message.score = object.score ?? 0;
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseAggregatedRating(): AggregatedRating {
  return { criterion: "", averageScore: 0, totalRatings: 0 };
}

export const AggregatedRating: MessageFns<AggregatedRating> = {
  encode(message: AggregatedRating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criterion !== "") {
      writer.uint32(10).string(message.criterion);
    }
    if (message.averageScore !== 0) {
      writer.uint32(17).double(message.averageScore);
    }
    if (message.totalRatings !== 0) {
      writer.uint32(24).int32(message.totalRatings);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedRating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.criterion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.averageScore = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalRatings = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedRating {
    return {
      criterion: isSet(object.criterion) ? globalThis.String(object.criterion) : "",
      averageScore: isSet(object.averageScore) ? globalThis.Number(object.averageScore) : 0,
      totalRatings: isSet(object.totalRatings) ? globalThis.Number(object.totalRatings) : 0,
    };
  },

  toJSON(message: AggregatedRating): unknown {
    const obj: any = {};
    if (message.criterion !== "") {
      obj.criterion = message.criterion;
    }
    if (message.averageScore !== 0) {
      obj.averageScore = message.averageScore;
    }
    if (message.totalRatings !== 0) {
      obj.totalRatings = Math.round(message.totalRatings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregatedRating>, I>>(base?: I): AggregatedRating {
    return AggregatedRating.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregatedRating>, I>>(object: I): AggregatedRating {
    const message = createBaseAggregatedRating();
    message.criterion = object.criterion ?? "";
    message.averageScore = object.averageScore ?? 0;
    message.totalRatings = object.totalRatings ?? 0;
    return message;
  },
};

function createBaseAggregatedRatingList(): AggregatedRatingList {
  return { ratings: [] };
}

export const AggregatedRatingList: MessageFns<AggregatedRatingList> = {
  encode(message: AggregatedRatingList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ratings) {
      AggregatedRating.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedRatingList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedRatingList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ratings.push(AggregatedRating.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedRatingList {
    return {
      ratings: globalThis.Array.isArray(object?.ratings)
        ? object.ratings.map((e: any) => AggregatedRating.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregatedRatingList): unknown {
    const obj: any = {};
    if (message.ratings?.length) {
      obj.ratings = message.ratings.map((e) => AggregatedRating.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregatedRatingList>, I>>(base?: I): AggregatedRatingList {
    return AggregatedRatingList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregatedRatingList>, I>>(object: I): AggregatedRatingList {
    const message = createBaseAggregatedRatingList();
    message.ratings = object.ratings?.map((e) => AggregatedRating.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompanyComment(): CompanyComment {
  return {
    id: 0,
    companyId: 0,
    content: "",
    isCurrentEmployee: false,
    sessionId: undefined,
    upvotes: 0,
    createdAt: undefined,
  };
}

export const CompanyComment: MessageFns<CompanyComment> = {
  encode(message: CompanyComment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.companyId !== 0) {
      writer.uint32(16).int32(message.companyId);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.isCurrentEmployee !== false) {
      writer.uint32(32).bool(message.isCurrentEmployee);
    }
    if (message.sessionId !== undefined) {
      StringValue.encode({ value: message.sessionId! }, writer.uint32(42).fork()).join();
    }
    if (message.upvotes !== 0) {
      writer.uint32(48).int32(message.upvotes);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyComment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.companyId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isCurrentEmployee = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sessionId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.upvotes = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyComment {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      companyId: isSet(object.companyId) ? globalThis.Number(object.companyId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isCurrentEmployee: isSet(object.isCurrentEmployee) ? globalThis.Boolean(object.isCurrentEmployee) : false,
      sessionId: isSet(object.sessionId) ? String(object.sessionId) : undefined,
      upvotes: isSet(object.upvotes) ? globalThis.Number(object.upvotes) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: CompanyComment): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.companyId !== 0) {
      obj.companyId = Math.round(message.companyId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isCurrentEmployee !== false) {
      obj.isCurrentEmployee = message.isCurrentEmployee;
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.upvotes !== 0) {
      obj.upvotes = Math.round(message.upvotes);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompanyComment>, I>>(base?: I): CompanyComment {
    return CompanyComment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompanyComment>, I>>(object: I): CompanyComment {
    const message = createBaseCompanyComment();
    message.id = object.id ?? 0;
    message.companyId = object.companyId ?? 0;
    message.content = object.content ?? "";
    message.isCurrentEmployee = object.isCurrentEmployee ?? false;
    message.sessionId = object.sessionId ?? undefined;
    message.upvotes = object.upvotes ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseCommentRequest(): CommentRequest {
  return { companyId: 0, content: "", isCurrentEmployee: false, sessionId: "" };
}

export const CommentRequest: MessageFns<CommentRequest> = {
  encode(message: CommentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.companyId !== 0) {
      writer.uint32(8).int32(message.companyId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.isCurrentEmployee !== false) {
      writer.uint32(24).bool(message.isCurrentEmployee);
    }
    if (message.sessionId !== "") {
      writer.uint32(34).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.companyId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isCurrentEmployee = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommentRequest {
    return {
      companyId: isSet(object.companyId) ? globalThis.Number(object.companyId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isCurrentEmployee: isSet(object.isCurrentEmployee) ? globalThis.Boolean(object.isCurrentEmployee) : false,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: CommentRequest): unknown {
    const obj: any = {};
    if (message.companyId !== 0) {
      obj.companyId = Math.round(message.companyId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isCurrentEmployee !== false) {
      obj.isCurrentEmployee = message.isCurrentEmployee;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommentRequest>, I>>(base?: I): CommentRequest {
    return CommentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommentRequest>, I>>(object: I): CommentRequest {
    const message = createBaseCommentRequest();
    message.companyId = object.companyId ?? 0;
    message.content = object.content ?? "";
    message.isCurrentEmployee = object.isCurrentEmployee ?? false;
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCommentList(): CommentList {
  return { comments: [] };
}

export const CommentList: MessageFns<CommentList> = {
  encode(message: CommentList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.comments) {
      CompanyComment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommentList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comments.push(CompanyComment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommentList {
    return {
      comments: globalThis.Array.isArray(object?.comments)
        ? object.comments.map((e: any) => CompanyComment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CommentList): unknown {
    const obj: any = {};
    if (message.comments?.length) {
      obj.comments = message.comments.map((e) => CompanyComment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommentList>, I>>(base?: I): CommentList {
    return CommentList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommentList>, I>>(object: I): CommentList {
    const message = createBaseCommentList();
    message.comments = object.comments?.map((e) => CompanyComment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLeaderboardRequest(): LeaderboardRequest {
  return { category: "", page: 0, pageSize: 0 };
}

export const LeaderboardRequest: MessageFns<LeaderboardRequest> = {
  encode(message: LeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaderboardRequest {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: LeaderboardRequest): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaderboardRequest>, I>>(base?: I): LeaderboardRequest {
    return LeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaderboardRequest>, I>>(object: I): LeaderboardRequest {
    const message = createBaseLeaderboardRequest();
    message.category = object.category ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseLeaderboardResponse(): LeaderboardResponse {
  return { companies: [], totalCount: 0, page: 0, pageSize: 0 };
}

export const LeaderboardResponse: MessageFns<LeaderboardResponse> = {
  encode(message: LeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companies) {
      Company.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companies.push(Company.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaderboardResponse {
    return {
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => Company.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: LeaderboardResponse): unknown {
    const obj: any = {};
    if (message.companies?.length) {
      obj.companies = message.companies.map((e) => Company.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaderboardResponse>, I>>(base?: I): LeaderboardResponse {
    return LeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaderboardResponse>, I>>(object: I): LeaderboardResponse {
    const message = createBaseLeaderboardResponse();
    message.companies = object.companies?.map((e) => Company.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseStatsResponse(): StatsResponse {
  return { totalCompanies: 0, totalVotes: 0, totalRatings: 0, totalComments: 0, categories: [] };
}

export const StatsResponse: MessageFns<StatsResponse> = {
  encode(message: StatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCompanies !== 0) {
      writer.uint32(8).int32(message.totalCompanies);
    }
    if (message.totalVotes !== 0) {
      writer.uint32(16).int32(message.totalVotes);
    }
    if (message.totalRatings !== 0) {
      writer.uint32(24).int32(message.totalRatings);
    }
    if (message.totalComments !== 0) {
      writer.uint32(32).int32(message.totalComments);
    }
    for (const v of message.categories) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCompanies = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalVotes = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalRatings = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalComments = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatsResponse {
    return {
      totalCompanies: isSet(object.totalCompanies) ? globalThis.Number(object.totalCompanies) : 0,
      totalVotes: isSet(object.totalVotes) ? globalThis.Number(object.totalVotes) : 0,
      totalRatings: isSet(object.totalRatings) ? globalThis.Number(object.totalRatings) : 0,
      totalComments: isSet(object.totalComments) ? globalThis.Number(object.totalComments) : 0,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StatsResponse): unknown {
    const obj: any = {};
    if (message.totalCompanies !== 0) {
      obj.totalCompanies = Math.round(message.totalCompanies);
    }
    if (message.totalVotes !== 0) {
      obj.totalVotes = Math.round(message.totalVotes);
    }
    if (message.totalRatings !== 0) {
      obj.totalRatings = Math.round(message.totalRatings);
    }
    if (message.totalComments !== 0) {
      obj.totalComments = Math.round(message.totalComments);
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatsResponse>, I>>(base?: I): StatsResponse {
    return StatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatsResponse>, I>>(object: I): StatsResponse {
    const message = createBaseStatsResponse();
    message.totalCompanies = object.totalCompanies ?? 0;
    message.totalVotes = object.totalVotes ?? 0;
    message.totalRatings = object.totalRatings ?? 0;
    message.totalComments = object.totalComments ?? 0;
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseCategoryCount(): CategoryCount {
  return { category: "", count: 0 };
}

export const CategoryCount: MessageFns<CategoryCount> = {
  encode(message: CategoryCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryCount {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CategoryCount): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryCount>, I>>(base?: I): CategoryCount {
    return CategoryCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryCount>, I>>(object: I): CategoryCount {
    const message = createBaseCategoryCount();
    message.category = object.category ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCategoryCountList(): CategoryCountList {
  return { categories: [] };
}

export const CategoryCountList: MessageFns<CategoryCountList> = {
  encode(message: CategoryCountList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      CategoryCount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryCountList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryCountList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.categories.push(CategoryCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryCountList {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => CategoryCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CategoryCountList): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => CategoryCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryCountList>, I>>(base?: I): CategoryCountList {
    return CategoryCountList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryCountList>, I>>(object: I): CategoryCountList {
    const message = createBaseCategoryCountList();
    message.categories = object.categories?.map((e) => CategoryCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { status: "", database: "" };
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(message: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.status = object.status ?? "";
    message.database = object.database ?? "";
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { error: "" };
}

export const ErrorResponse: MessageFns<ErrorResponse> = {
  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return { error: isSet(object.error) ? globalThis.String(object.error) : "" };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetCompaniesRequest(): GetCompaniesRequest {
  return { category: "", search: "" };
}

export const GetCompaniesRequest: MessageFns<GetCompaniesRequest> = {
  encode(message: GetCompaniesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.search !== "") {
      writer.uint32(18).string(message.search);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompaniesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompaniesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.search = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompaniesRequest {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      search: isSet(object.search) ? globalThis.String(object.search) : "",
    };
  },

  toJSON(message: GetCompaniesRequest): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompaniesRequest>, I>>(base?: I): GetCompaniesRequest {
    return GetCompaniesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompaniesRequest>, I>>(object: I): GetCompaniesRequest {
    const message = createBaseGetCompaniesRequest();
    message.category = object.category ?? "";
    message.search = object.search ?? "";
    return message;
  },
};

function createBaseGetCompanyRequest(): GetCompanyRequest {
  return { slug: "" };
}

export const GetCompanyRequest: MessageFns<GetCompanyRequest> = {
  encode(message: GetCompanyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompanyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompanyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompanyRequest {
    return { slug: isSet(object.slug) ? globalThis.String(object.slug) : "" };
  },

  toJSON(message: GetCompanyRequest): unknown {
    const obj: any = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompanyRequest>, I>>(base?: I): GetCompanyRequest {
    return GetCompanyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompanyRequest>, I>>(object: I): GetCompanyRequest {
    const message = createBaseGetCompanyRequest();
    message.slug = object.slug ?? "";
    return message;
  },
};

function createBaseGetMatchupRequest(): GetMatchupRequest {
  return { category: "" };
}

export const GetMatchupRequest: MessageFns<GetMatchupRequest> = {
  encode(message: GetMatchupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMatchupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMatchupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMatchupRequest {
    return { category: isSet(object.category) ? globalThis.String(object.category) : "" };
  },

  toJSON(message: GetMatchupRequest): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMatchupRequest>, I>>(base?: I): GetMatchupRequest {
    return GetMatchupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMatchupRequest>, I>>(object: I): GetMatchupRequest {
    const message = createBaseGetMatchupRequest();
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseUpvoteCommentRequest(): UpvoteCommentRequest {
  return { commentId: 0 };
}

export const UpvoteCommentRequest: MessageFns<UpvoteCommentRequest> = {
  encode(message: UpvoteCommentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commentId !== 0) {
      writer.uint32(8).int32(message.commentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpvoteCommentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpvoteCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.commentId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpvoteCommentRequest {
    return { commentId: isSet(object.commentId) ? globalThis.Number(object.commentId) : 0 };
  },

  toJSON(message: UpvoteCommentRequest): unknown {
    const obj: any = {};
    if (message.commentId !== 0) {
      obj.commentId = Math.round(message.commentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpvoteCommentRequest>, I>>(base?: I): UpvoteCommentRequest {
    return UpvoteCommentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpvoteCommentRequest>, I>>(object: I): UpvoteCommentRequest {
    const message = createBaseUpvoteCommentRequest();
    message.commentId = object.commentId ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
